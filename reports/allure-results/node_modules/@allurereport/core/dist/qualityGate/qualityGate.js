var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _QualityGateState_state;
import { gray, red } from "yoctocolors";
import { qualityGateDefaultRules } from "./rules.js";
export const stringifyQualityGateResults = (results) => {
    if (results.length === 0) {
        return "";
    }
    const lines = [red("Quality Gate failed with following issues:")];
    const maxMessageLength = Math.max(...results.map((r) => r.message.length));
    lines.push("");
    results.forEach((result) => {
        lines.push(` ${red("тип")} ${result.message.padEnd(maxMessageLength, " ")}    ${gray(result.rule)}`);
    });
    lines.push("");
    lines.push(red(`${results.length} quality gate rules have been failed.`));
    return lines.join("\n");
};
export const convertQualityGateResultsToTestErrors = (results) => {
    return results.map((result) => ({
        message: `Quality Gate (${result.rule}): ${result.message}`,
        actual: result.actual,
        expected: result.expected,
    }));
};
export class QualityGateState {
    constructor() {
        _QualityGateState_state.set(this, {});
    }
    setResult(rule, value) {
        __classPrivateFieldGet(this, _QualityGateState_state, "f")[rule] = value;
    }
    getResult(rule) {
        return __classPrivateFieldGet(this, _QualityGateState_state, "f")[rule];
    }
}
_QualityGateState_state = new WeakMap();
export class QualityGate {
    constructor(config) {
        this.config = config;
    }
    async validate(payload) {
        const { state, trs, knownIssues } = payload;
        const { rules, use = [...qualityGateDefaultRules] } = this.config;
        const results = [];
        let fastFailed = false;
        if (!rules?.length) {
            return {
                fastFailed: false,
                results,
            };
        }
        for (const ruleset of rules) {
            if (fastFailed) {
                break;
            }
            for (const [key, value] of Object.entries(ruleset)) {
                if (key === "filter" || key === "id" || key === "fastFail") {
                    continue;
                }
                const rule = use.filter((r) => r.rule === key).pop();
                if (!rule) {
                    throw new Error(`Rule ${key} is not provided. Make sure you have provided it in the "use" field of the quality gate config!`);
                }
                const ruleId = ruleset.id ? [ruleset.id, rule.rule].join("/") : rule.rule;
                const result = await rule.validate({
                    expected: value,
                    trs,
                    knownIssues,
                    state: state?.getResult?.(ruleId),
                });
                state?.setResult(ruleId, result.actual);
                if (result.success) {
                    continue;
                }
                results.push({
                    ...result,
                    rule: ruleset.id ? [ruleset.id, rule.rule].join("/") : rule.rule,
                    message: rule.message(result),
                });
                if (ruleset.fastFail) {
                    fastFailed = true;
                    break;
                }
            }
        }
        return {
            fastFailed,
            results,
        };
    }
}
