var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _AllureReport_instances, _AllureReport_reportName, _AllureReport_ci, _AllureReport_store, _AllureReport_readers, _AllureReport_plugins, _AllureReport_reportFiles, _AllureReport_eventEmitter, _AllureReport_realtimeSubscriber, _AllureReport_realtimeDispatcher, _AllureReport_realTime, _AllureReport_output, _AllureReport_history, _AllureReport_allureServiceClient, _AllureReport_qualityGate, _AllureReport_state, _AllureReport_stage, _AllureReport_publish_get, _AllureReport_update, _AllureReport_eachPlugin, _AllureReport_getPluginState;
import { detect } from "@allurereport/ci";
import { allure1, allure2, attachments, cucumberjson, junitXml, readXcResultBundle } from "@allurereport/reader";
import { PathResultFile } from "@allurereport/reader-api";
import { AllureRemoteHistory, AllureServiceClient, KnownError, UnknownError } from "@allurereport/service";
import { generateSummary } from "@allurereport/summary";
import console from "node:console";
import { randomUUID } from "node:crypto";
import { EventEmitter } from "node:events";
import { readFileSync } from "node:fs";
import { lstat, opendir, readdir, realpath, rename, rm, writeFile } from "node:fs/promises";
import { dirname, join, resolve } from "node:path";
import { AllureLocalHistory, createHistory } from "./history.js";
import { DefaultPluginState, PluginFiles } from "./plugin.js";
import { QualityGate } from "./qualityGate/index.js";
import { DefaultAllureStore } from "./store/store.js";
import { RealtimeEventsDispatcher, RealtimeSubscriber } from "./utils/event.js";
const { version } = JSON.parse(readFileSync(new URL("../package.json", import.meta.url), "utf8"));
const initRequired = "report is not initialised. Call the start() method first.";
export class AllureReport {
    constructor(opts) {
        _AllureReport_instances.add(this);
        _AllureReport_reportName.set(this, void 0);
        _AllureReport_ci.set(this, void 0);
        _AllureReport_store.set(this, void 0);
        _AllureReport_readers.set(this, void 0);
        _AllureReport_plugins.set(this, void 0);
        _AllureReport_reportFiles.set(this, void 0);
        _AllureReport_eventEmitter.set(this, void 0);
        _AllureReport_realtimeSubscriber.set(this, void 0);
        _AllureReport_realtimeDispatcher.set(this, void 0);
        _AllureReport_realTime.set(this, void 0);
        _AllureReport_output.set(this, void 0);
        _AllureReport_history.set(this, void 0);
        _AllureReport_allureServiceClient.set(this, void 0);
        _AllureReport_qualityGate.set(this, void 0);
        _AllureReport_state.set(this, void 0);
        _AllureReport_stage.set(this, "init");
        this.readDirectory = async (resultsDir) => {
            if (__classPrivateFieldGet(this, _AllureReport_stage, "f") !== "running") {
                throw new Error(initRequired);
            }
            const resultsDirPath = resolve(resultsDir);
            if (await readXcResultBundle(__classPrivateFieldGet(this, _AllureReport_store, "f"), resultsDirPath)) {
                return;
            }
            const dir = await opendir(resultsDirPath);
            try {
                for await (const dirent of dir) {
                    if (dirent.isFile()) {
                        const path = await realpath(join(dirent.parentPath ?? dirent.path, dirent.name));
                        await this.readResult(new PathResultFile(path, dirent.name));
                    }
                }
            }
            catch (e) {
                console.error("can't read directory", e);
            }
        };
        this.readFile = async (resultsFile) => {
            if (__classPrivateFieldGet(this, _AllureReport_stage, "f") !== "running") {
                throw new Error(initRequired);
            }
            await this.readResult(new PathResultFile(resultsFile));
        };
        this.readResult = async (data) => {
            if (__classPrivateFieldGet(this, _AllureReport_stage, "f") !== "running") {
                throw new Error(initRequired);
            }
            for (const reader of __classPrivateFieldGet(this, _AllureReport_readers, "f")) {
                try {
                    const processed = await reader.read(__classPrivateFieldGet(this, _AllureReport_store, "f"), data);
                    if (processed) {
                        return;
                    }
                }
                catch (ignored) { }
            }
        };
        this.validate = async (params) => {
            const { trs, knownIssues, state } = params;
            return __classPrivateFieldGet(this, _AllureReport_qualityGate, "f").validate({
                trs: trs.filter(Boolean),
                knownIssues,
                state,
            });
        };
        this.start = async () => {
            await __classPrivateFieldGet(this, _AllureReport_store, "f").readHistory();
            if (__classPrivateFieldGet(this, _AllureReport_stage, "f") === "running") {
                throw new Error("the report is already started");
            }
            if (__classPrivateFieldGet(this, _AllureReport_stage, "f") === "done") {
                throw new Error("the report is already stopped, the restart isn't supported at the moment");
            }
            __classPrivateFieldSet(this, _AllureReport_stage, "running", "f");
            if (__classPrivateFieldGet(this, _AllureReport_allureServiceClient, "f") && __classPrivateFieldGet(this, _AllureReport_instances, "a", _AllureReport_publish_get)) {
                const { url } = await __classPrivateFieldGet(this, _AllureReport_allureServiceClient, "f").createReport({
                    reportUuid: this.reportUuid,
                    reportName: __classPrivateFieldGet(this, _AllureReport_reportName, "f"),
                });
                this.reportUrl = url;
            }
            await __classPrivateFieldGet(this, _AllureReport_eachPlugin, "f").call(this, true, async (plugin, context) => {
                await plugin.start?.(context, __classPrivateFieldGet(this, _AllureReport_store, "f"), __classPrivateFieldGet(this, _AllureReport_realtimeSubscriber, "f"));
            });
            if (__classPrivateFieldGet(this, _AllureReport_realTime, "f")) {
                await __classPrivateFieldGet(this, _AllureReport_update, "f").call(this);
                __classPrivateFieldGet(this, _AllureReport_realtimeSubscriber, "f").onAll(async () => {
                    await __classPrivateFieldGet(this, _AllureReport_update, "f").call(this);
                });
            }
        };
        _AllureReport_update.set(this, async () => {
            if (__classPrivateFieldGet(this, _AllureReport_stage, "f") !== "running") {
                return;
            }
            await __classPrivateFieldGet(this, _AllureReport_eachPlugin, "f").call(this, false, async (plugin, context) => {
                await plugin.update?.(context, __classPrivateFieldGet(this, _AllureReport_store, "f"));
            });
        });
        this.done = async () => {
            const summaries = [];
            const remoteHrefs = [];
            if (__classPrivateFieldGet(this, _AllureReport_stage, "f") !== "running") {
                throw new Error(initRequired);
            }
            __classPrivateFieldGet(this, _AllureReport_realtimeSubscriber, "f").offAll();
            __classPrivateFieldSet(this, _AllureReport_stage, "done", "f");
            await __classPrivateFieldGet(this, _AllureReport_eachPlugin, "f").call(this, false, async (plugin, context) => {
                await plugin.done?.(context, __classPrivateFieldGet(this, _AllureReport_store, "f"));
                if (__classPrivateFieldGet(this, _AllureReport_allureServiceClient, "f") && context.publish) {
                    const pluginFiles = (await context.state.get("files")) ?? {};
                    for (const [filename, filepath] of Object.entries(pluginFiles)) {
                        if (/^(data|widgets|index\.html$)/.test(filename)) {
                            await __classPrivateFieldGet(this, _AllureReport_allureServiceClient, "f").addReportFile({
                                reportUuid: this.reportUuid,
                                pluginId: context.id,
                                filename,
                                filepath,
                            });
                        }
                        else {
                            await __classPrivateFieldGet(this, _AllureReport_allureServiceClient, "f").addReportAsset({
                                filename,
                                filepath,
                            });
                        }
                    }
                }
                const summary = await plugin?.info?.(context, __classPrivateFieldGet(this, _AllureReport_store, "f"));
                if (!summary) {
                    return;
                }
                summary.pullRequestHref = __classPrivateFieldGet(this, _AllureReport_ci, "f")?.pullRequestUrl;
                summary.jobHref = __classPrivateFieldGet(this, _AllureReport_ci, "f")?.jobRunUrl;
                if (context.publish) {
                    summary.remoteHref = `${this.reportUrl}/${context.id}/`;
                    remoteHrefs.push(summary.remoteHref);
                }
                summaries.push({
                    ...summary,
                    href: `${context.id}/`,
                });
                await context.reportFiles.addFile("summary.json", Buffer.from(JSON.stringify(summary)));
            });
            if (__classPrivateFieldGet(this, _AllureReport_instances, "a", _AllureReport_publish_get)) {
                await __classPrivateFieldGet(this, _AllureReport_allureServiceClient, "f")?.completeReport({
                    reportUuid: this.reportUuid,
                });
            }
            let outputDirFiles = [];
            try {
                outputDirFiles = await readdir(__classPrivateFieldGet(this, _AllureReport_output, "f"));
            }
            catch (ignored) { }
            if (outputDirFiles.length === 0) {
                return;
            }
            const reportPath = join(__classPrivateFieldGet(this, _AllureReport_output, "f"), outputDirFiles[0]);
            const outputEntriesStats = await Promise.all(outputDirFiles.map((file) => lstat(join(__classPrivateFieldGet(this, _AllureReport_output, "f"), file))));
            const outputDirectoryEntries = outputEntriesStats.filter((entry) => entry.isDirectory());
            if (outputDirectoryEntries.length === 1) {
                const reportContent = await readdir(reportPath);
                for (const entry of reportContent) {
                    const currentFilePath = join(reportPath, entry);
                    const newFilePath = resolve(dirname(currentFilePath), "..", entry);
                    await rename(currentFilePath, newFilePath);
                }
                await rm(reportPath, { recursive: true });
            }
            if (__classPrivateFieldGet(this, _AllureReport_history, "f")) {
                const testResults = await __classPrivateFieldGet(this, _AllureReport_store, "f").allTestResults();
                const testCases = await __classPrivateFieldGet(this, _AllureReport_store, "f").allTestCases();
                const historyDataPoint = createHistory(this.reportUuid, __classPrivateFieldGet(this, _AllureReport_reportName, "f"), testCases, testResults, this.reportUrl);
                try {
                    await __classPrivateFieldGet(this, _AllureReport_store, "f").appendHistory(historyDataPoint);
                }
                catch (err) {
                    if (err instanceof KnownError) {
                        console.error("Failed to append history", err.message);
                    }
                    else if (err instanceof UnknownError) {
                        console.error("Failed to append history due to unexpected error", err.message);
                    }
                    else {
                        throw err;
                    }
                }
            }
            if (summaries.length > 1) {
                await generateSummary(__classPrivateFieldGet(this, _AllureReport_output, "f"), summaries);
            }
            if (remoteHrefs.length > 0) {
                console.info("Next reports have been published:");
                remoteHrefs.forEach((href) => {
                    console.info(`- ${href}`);
                });
            }
            if (!__classPrivateFieldGet(this, _AllureReport_qualityGate, "f")) {
                return;
            }
            const qualityGateResults = await __classPrivateFieldGet(this, _AllureReport_store, "f").qualityGateResults();
            await writeFile(join(__classPrivateFieldGet(this, _AllureReport_output, "f"), "quality-gate.json"), JSON.stringify(qualityGateResults));
        };
        _AllureReport_eachPlugin.set(this, async (initState, consumer) => {
            if (initState) {
                __classPrivateFieldSet(this, _AllureReport_state, {}, "f");
            }
            for (const { enabled, id, plugin, options } of __classPrivateFieldGet(this, _AllureReport_plugins, "f")) {
                if (!enabled) {
                    continue;
                }
                const pluginState = __classPrivateFieldGet(this, _AllureReport_instances, "m", _AllureReport_getPluginState).call(this, initState, id);
                if (!pluginState) {
                    console.error("plugin error: state is empty");
                    continue;
                }
                if (initState) {
                    await pluginState.set("files", {});
                }
                const pluginFiles = new PluginFiles(__classPrivateFieldGet(this, _AllureReport_reportFiles, "f"), id, async (key, filepath) => {
                    const currentPluginState = __classPrivateFieldGet(this, _AllureReport_instances, "m", _AllureReport_getPluginState).call(this, false, id);
                    const files = await currentPluginState?.get("files");
                    if (!files) {
                        return;
                    }
                    files[key] = filepath;
                });
                const pluginContext = {
                    id,
                    publish: !!options?.publish,
                    allureVersion: version,
                    reportUuid: this.reportUuid,
                    reportName: __classPrivateFieldGet(this, _AllureReport_reportName, "f"),
                    state: pluginState,
                    reportFiles: pluginFiles,
                    ci: __classPrivateFieldGet(this, _AllureReport_ci, "f"),
                };
                try {
                    await consumer.call(this, plugin, pluginContext);
                    if (initState) {
                        __classPrivateFieldGet(this, _AllureReport_state, "f")[id] = pluginState;
                    }
                }
                catch (e) {
                    console.error(`plugin ${id} error`, e);
                }
            }
        });
        const { name, readers = [allure1, allure2, cucumberjson, junitXml, attachments], plugins = [], known, reportFiles, realTime, historyPath, defaultLabels = {}, variables = {}, environments, output, qualityGate, allureService: allureServiceConfig, } = opts;
        __classPrivateFieldSet(this, _AllureReport_allureServiceClient, allureServiceConfig?.url ? new AllureServiceClient(allureServiceConfig) : undefined, "f");
        this.reportUuid = randomUUID();
        __classPrivateFieldSet(this, _AllureReport_ci, detect(), "f");
        const reportTitleSuffix = __classPrivateFieldGet(this, _AllureReport_ci, "f")?.pullRequestName ?? __classPrivateFieldGet(this, _AllureReport_ci, "f")?.jobRunName;
        __classPrivateFieldSet(this, _AllureReport_reportName, [name, reportTitleSuffix].filter(Boolean).join(" – "), "f");
        __classPrivateFieldSet(this, _AllureReport_eventEmitter, new EventEmitter(), "f");
        __classPrivateFieldSet(this, _AllureReport_realtimeDispatcher, new RealtimeEventsDispatcher(__classPrivateFieldGet(this, _AllureReport_eventEmitter, "f")), "f");
        __classPrivateFieldSet(this, _AllureReport_realtimeSubscriber, new RealtimeSubscriber(__classPrivateFieldGet(this, _AllureReport_eventEmitter, "f")), "f");
        __classPrivateFieldSet(this, _AllureReport_realTime, realTime, "f");
        if (__classPrivateFieldGet(this, _AllureReport_allureServiceClient, "f")) {
            __classPrivateFieldSet(this, _AllureReport_history, new AllureRemoteHistory(__classPrivateFieldGet(this, _AllureReport_allureServiceClient, "f")), "f");
        }
        else if (historyPath) {
            __classPrivateFieldSet(this, _AllureReport_history, new AllureLocalHistory(historyPath), "f");
        }
        if (qualityGate) {
            __classPrivateFieldSet(this, _AllureReport_qualityGate, new QualityGate(qualityGate), "f");
        }
        __classPrivateFieldSet(this, _AllureReport_store, new DefaultAllureStore({
            realtimeSubscriber: __classPrivateFieldGet(this, _AllureReport_realtimeSubscriber, "f"),
            realtimeDispatcher: __classPrivateFieldGet(this, _AllureReport_realtimeDispatcher, "f"),
            reportVariables: variables,
            environmentsConfig: environments,
            history: __classPrivateFieldGet(this, _AllureReport_history, "f"),
            known,
            defaultLabels,
        }), "f");
        __classPrivateFieldSet(this, _AllureReport_readers, [...readers], "f");
        __classPrivateFieldSet(this, _AllureReport_plugins, [...plugins], "f");
        __classPrivateFieldSet(this, _AllureReport_reportFiles, reportFiles, "f");
        __classPrivateFieldSet(this, _AllureReport_output, output, "f");
        __classPrivateFieldSet(this, _AllureReport_history, __classPrivateFieldGet(this, _AllureReport_allureServiceClient, "f")
            ? new AllureRemoteHistory(__classPrivateFieldGet(this, _AllureReport_allureServiceClient, "f"))
            : new AllureLocalHistory(historyPath), "f");
    }
    get hasQualityGate() {
        return !!__classPrivateFieldGet(this, _AllureReport_qualityGate, "f");
    }
    get store() {
        return __classPrivateFieldGet(this, _AllureReport_store, "f");
    }
    get realtimeSubscriber() {
        return __classPrivateFieldGet(this, _AllureReport_realtimeSubscriber, "f");
    }
    get realtimeDispatcher() {
        return __classPrivateFieldGet(this, _AllureReport_realtimeDispatcher, "f");
    }
}
_AllureReport_reportName = new WeakMap(), _AllureReport_ci = new WeakMap(), _AllureReport_store = new WeakMap(), _AllureReport_readers = new WeakMap(), _AllureReport_plugins = new WeakMap(), _AllureReport_reportFiles = new WeakMap(), _AllureReport_eventEmitter = new WeakMap(), _AllureReport_realtimeSubscriber = new WeakMap(), _AllureReport_realtimeDispatcher = new WeakMap(), _AllureReport_realTime = new WeakMap(), _AllureReport_output = new WeakMap(), _AllureReport_history = new WeakMap(), _AllureReport_allureServiceClient = new WeakMap(), _AllureReport_qualityGate = new WeakMap(), _AllureReport_state = new WeakMap(), _AllureReport_stage = new WeakMap(), _AllureReport_update = new WeakMap(), _AllureReport_eachPlugin = new WeakMap(), _AllureReport_instances = new WeakSet(), _AllureReport_publish_get = function _AllureReport_publish_get() {
    return __classPrivateFieldGet(this, _AllureReport_plugins, "f").some(({ enabled, options }) => enabled && options.publish);
}, _AllureReport_getPluginState = function _AllureReport_getPluginState(init, id) {
    return init ? new DefaultPluginState({}) : __classPrivateFieldGet(this, _AllureReport_state, "f")?.[id];
};
