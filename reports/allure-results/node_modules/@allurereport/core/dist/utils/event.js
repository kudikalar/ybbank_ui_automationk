var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _RealtimeEventsDispatcher_emitter, _RealtimeSubscriber_instances, _RealtimeSubscriber_emitter, _RealtimeSubscriber_handlers, _RealtimeSubscriber_createBatchHandler;
import console from "node:console";
import { setTimeout } from "node:timers/promises";
export var RealtimeEvents;
(function (RealtimeEvents) {
    RealtimeEvents["TestResult"] = "testResult";
    RealtimeEvents["TestFixtureResult"] = "testFixtureResult";
    RealtimeEvents["AttachmentFile"] = "attachmentFile";
    RealtimeEvents["QualityGateResults"] = "qualityGateResults";
    RealtimeEvents["GlobalAttachment"] = "globalAttachment";
    RealtimeEvents["GlobalError"] = "globalError";
    RealtimeEvents["GlobalExitCode"] = "globalExitCode";
})(RealtimeEvents || (RealtimeEvents = {}));
export class RealtimeEventsDispatcher {
    constructor(emitter) {
        _RealtimeEventsDispatcher_emitter.set(this, void 0);
        __classPrivateFieldSet(this, _RealtimeEventsDispatcher_emitter, emitter, "f");
    }
    sendGlobalAttachment(attachment) {
        __classPrivateFieldGet(this, _RealtimeEventsDispatcher_emitter, "f").emit(RealtimeEvents.GlobalAttachment, attachment);
    }
    sendGlobalExitCode(codes) {
        __classPrivateFieldGet(this, _RealtimeEventsDispatcher_emitter, "f").emit(RealtimeEvents.GlobalExitCode, codes);
    }
    sendGlobalError(error) {
        __classPrivateFieldGet(this, _RealtimeEventsDispatcher_emitter, "f").emit(RealtimeEvents.GlobalError, error);
    }
    sendQualityGateResults(payload) {
        __classPrivateFieldGet(this, _RealtimeEventsDispatcher_emitter, "f").emit(RealtimeEvents.QualityGateResults, payload ?? []);
    }
    sendTestResult(trId) {
        __classPrivateFieldGet(this, _RealtimeEventsDispatcher_emitter, "f").emit(RealtimeEvents.TestResult, trId);
    }
    sendTestFixtureResult(tfrId) {
        __classPrivateFieldGet(this, _RealtimeEventsDispatcher_emitter, "f").emit(RealtimeEvents.TestFixtureResult, tfrId);
    }
    sendAttachmentFile(afId) {
        __classPrivateFieldGet(this, _RealtimeEventsDispatcher_emitter, "f").emit(RealtimeEvents.AttachmentFile, afId);
    }
}
_RealtimeEventsDispatcher_emitter = new WeakMap();
export class RealtimeSubscriber {
    constructor(emitter) {
        _RealtimeSubscriber_instances.add(this);
        _RealtimeSubscriber_emitter.set(this, void 0);
        _RealtimeSubscriber_handlers.set(this, []);
        __classPrivateFieldSet(this, _RealtimeSubscriber_emitter, emitter, "f");
    }
    onGlobalAttachment(listener) {
        __classPrivateFieldGet(this, _RealtimeSubscriber_emitter, "f").on(RealtimeEvents.GlobalAttachment, listener);
        return () => {
            __classPrivateFieldGet(this, _RealtimeSubscriber_emitter, "f").off(RealtimeEvents.GlobalAttachment, listener);
        };
    }
    onGlobalExitCode(listener) {
        __classPrivateFieldGet(this, _RealtimeSubscriber_emitter, "f").on(RealtimeEvents.GlobalExitCode, listener);
        return () => {
            __classPrivateFieldGet(this, _RealtimeSubscriber_emitter, "f").off(RealtimeEvents.GlobalExitCode, listener);
        };
    }
    onGlobalError(listener) {
        __classPrivateFieldGet(this, _RealtimeSubscriber_emitter, "f").on(RealtimeEvents.GlobalError, listener);
        return () => {
            __classPrivateFieldGet(this, _RealtimeSubscriber_emitter, "f").off(RealtimeEvents.GlobalError, listener);
        };
    }
    onQualityGateResults(listener) {
        __classPrivateFieldGet(this, _RealtimeSubscriber_emitter, "f").on(RealtimeEvents.QualityGateResults, listener);
        return () => {
            __classPrivateFieldGet(this, _RealtimeSubscriber_emitter, "f").off(RealtimeEvents.QualityGateResults, listener);
        };
    }
    onTestResults(listener, options = {}) {
        const { maxTimeout = 100 } = options;
        const handler = __classPrivateFieldGet(this, _RealtimeSubscriber_instances, "m", _RealtimeSubscriber_createBatchHandler).call(this, maxTimeout, listener);
        __classPrivateFieldGet(this, _RealtimeSubscriber_emitter, "f").on(RealtimeEvents.TestResult, handler);
        return () => {
            __classPrivateFieldGet(this, _RealtimeSubscriber_emitter, "f").off(RealtimeEvents.TestResult, handler);
        };
    }
    onTestFixtureResults(listener, options = {}) {
        const { maxTimeout = 100 } = options;
        const handler = __classPrivateFieldGet(this, _RealtimeSubscriber_instances, "m", _RealtimeSubscriber_createBatchHandler).call(this, maxTimeout, listener);
        __classPrivateFieldGet(this, _RealtimeSubscriber_emitter, "f").on(RealtimeEvents.TestFixtureResult, handler);
        return () => {
            __classPrivateFieldGet(this, _RealtimeSubscriber_emitter, "f").off(RealtimeEvents.TestFixtureResult, handler);
        };
    }
    onAttachmentFiles(listener, options = {}) {
        const { maxTimeout = 100 } = options;
        const handler = __classPrivateFieldGet(this, _RealtimeSubscriber_instances, "m", _RealtimeSubscriber_createBatchHandler).call(this, maxTimeout, listener);
        __classPrivateFieldGet(this, _RealtimeSubscriber_emitter, "f").on(RealtimeEvents.AttachmentFile, handler);
        return () => {
            __classPrivateFieldGet(this, _RealtimeSubscriber_emitter, "f").off(RealtimeEvents.AttachmentFile, handler);
        };
    }
    onAll(listener, options = {}) {
        const { maxTimeout = 100 } = options;
        const handler = __classPrivateFieldGet(this, _RealtimeSubscriber_instances, "m", _RealtimeSubscriber_createBatchHandler).call(this, maxTimeout, listener);
        __classPrivateFieldGet(this, _RealtimeSubscriber_emitter, "f").on(RealtimeEvents.TestResult, handler);
        __classPrivateFieldGet(this, _RealtimeSubscriber_emitter, "f").on(RealtimeEvents.TestFixtureResult, handler);
        __classPrivateFieldGet(this, _RealtimeSubscriber_emitter, "f").on(RealtimeEvents.AttachmentFile, handler);
        return () => {
            __classPrivateFieldGet(this, _RealtimeSubscriber_emitter, "f").off(RealtimeEvents.TestResult, handler);
            __classPrivateFieldGet(this, _RealtimeSubscriber_emitter, "f").off(RealtimeEvents.TestFixtureResult, handler);
            __classPrivateFieldGet(this, _RealtimeSubscriber_emitter, "f").off(RealtimeEvents.AttachmentFile, handler);
        };
    }
    offAll() {
        __classPrivateFieldGet(this, _RealtimeSubscriber_emitter, "f").removeAllListeners();
        for (const handler of __classPrivateFieldGet(this, _RealtimeSubscriber_handlers, "f")) {
            handler.ac?.abort();
        }
        __classPrivateFieldSet(this, _RealtimeSubscriber_handlers, [], "f");
    }
}
_RealtimeSubscriber_emitter = new WeakMap(), _RealtimeSubscriber_handlers = new WeakMap(), _RealtimeSubscriber_instances = new WeakSet(), _RealtimeSubscriber_createBatchHandler = function _RealtimeSubscriber_createBatchHandler(maxTimeout, listener) {
    const handler = {
        buffer: [],
    };
    __classPrivateFieldGet(this, _RealtimeSubscriber_handlers, "f").push(handler);
    return (trId) => {
        handler.buffer.push(trId);
        if (handler.timeout) {
            return;
        }
        handler.ac = new AbortController();
        handler.timeout = setTimeout(maxTimeout, undefined, { signal: handler.ac.signal })
            .then(() => {
            handler.timeout = undefined;
            const bufferCopy = [...handler.buffer];
            handler.buffer = [];
            handler.ac = undefined;
            return listener(bufferCopy);
        })
            .catch((err) => {
            if (err.name === "AbortError") {
                return;
            }
            console.error("can't execute listener", err);
        });
    };
};
