declare const unknownKey: unique symbol;
export type Unknown<T> = typeof unknownKey | ShallowKnown<T> | undefined | null;
export type ShallowKnown<T> = T extends object ? T extends (...v: any[]) => any ? T : {
    [key in keyof T]: Unknown<T[key]>;
} : T;
export type IsSuper<SuperType, SubType> = [SubType] extends [never] ? never : [SubType] extends [SuperType] ? SuperType : never;
export type Narrow<SuperType, SubType> = [SubType] extends [never] ? never : [SubType] extends [SuperType] ? SubType : never;
export type ArrayElement<T> = T extends readonly (infer E)[] ? E : never;
export type IsHomogeneousObject<T> = T extends object ? T extends readonly any[] ? never : T extends {
    [key in keyof T]: infer U;
} ? {
    [key in keyof T]: U;
} extends T ? T : never : never : never;
export type NarrowHomogeneousObject<T, R> = T extends object ? T extends readonly any[] ? never : T extends {
    [key in keyof T]: infer U;
} ? {
    [key in keyof T]: U;
} extends T ? {
    [key in keyof T]?: R;
} : never : never : never;
export type HomogeneousObjectItem<T> = T extends object ? T extends readonly any[] ? never : T extends {
    [key in keyof T]: infer U;
} ? {
    [key in keyof T]: U;
} extends T ? U : never : never : never;
export type ConditionalUnion<CA, A, CB, B> = [CA] extends [never] ? B : [CB] extends [never] ? A : A | B;
export declare const isDefined: <T>(value: T | undefined) => value is T;
export declare const isString: <T>(value: Unknown<IsSuper<T, string>>) => value is ShallowKnown<Narrow<T, string>>;
export declare const isNumber: <T>(value: Unknown<IsSuper<T, number>>) => value is ShallowKnown<Narrow<T, number>>;
export declare const isBoolean: <T>(value: Unknown<IsSuper<T, boolean>>) => value is ShallowKnown<Narrow<T, boolean>>;
export declare const isArray: <T>(value: Unknown<IsSuper<T, Extract<T, readonly any[]>>>) => value is ShallowKnown<Extract<Narrow<T, Extract<T, readonly any[]>>, readonly any[]>>;
export declare const isObject: <T>(value: Unknown<IsSuper<T, Extract<Exclude<T, readonly any[]>, object>>>) => value is ShallowKnown<Narrow<T, Extract<Exclude<T, readonly any[]>, object>>>;
export declare const isLiteral: <T, const L extends readonly any[]>(value: Unknown<IsSuper<T, L[number]>>, literals: L) => value is ShallowKnown<L[number]>;
export declare const ensureString: <T>(value: Unknown<T>) => string | undefined;
export declare const ensureNumber: <T>(value: Unknown<T>) => number | undefined;
export declare const ensureBoolean: <T>(value: Unknown<T>) => boolean | undefined;
export declare const ensureInt: <T>(value: Unknown<T>) => number | undefined;
export declare const ensureFloat: <T>(value: Unknown<T>) => number | undefined;
export declare const ensureArray: <T>(value: Unknown<IsSuper<T, Extract<T, readonly any[]>>>) => ShallowKnown<Extract<Narrow<T, Extract<T, readonly any[]>>, readonly any[]>> | undefined;
export declare const ensureObject: <T>(value: Unknown<IsSuper<T, Extract<Exclude<T, readonly any[]>, object>>>) => ShallowKnown<Narrow<T, Extract<Exclude<T, readonly any[]>, object>>> | undefined;
export declare const ensureLiteral: <T, const L extends readonly any[]>(value: Unknown<T>, literals: L) => ShallowKnown<L[number]> | undefined;
export declare const ensureArrayWithItems: <T, R extends ShallowKnown<ArrayElement<T>>>(value: Unknown<IsSuper<T, Extract<T, ArrayElement<T>[]>>>, guard: (v: Unknown<ArrayElement<T>>) => v is R) => R[] | undefined;
export declare const ensureObjectWithProps: <T, R extends ShallowKnown<HomogeneousObjectItem<T>>>(value: Unknown<IsSuper<T, Extract<T, IsHomogeneousObject<T>>>>, guard: (v: Unknown<HomogeneousObjectItem<T>>) => v is R) => NarrowHomogeneousObject<T, R> | undefined;
export declare const ensureItems: <T, R extends ShallowKnown<HomogeneousObjectItem<T> | ArrayElement<T>>>(value: Unknown<IsSuper<T, Extract<T, IsHomogeneousObject<T> | ArrayElement<T>[]>>>, guard: (v: Unknown<HomogeneousObjectItem<T> | ArrayElement<T>>) => v is R) => ConditionalUnion<ArrayElement<T>, R[], IsHomogeneousObject<T>, NarrowHomogeneousObject<T, R>> | undefined;
export {};
