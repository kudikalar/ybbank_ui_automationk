var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _LegacyApiParser_instances, _LegacyApiParser_xcode16Plus, _LegacyApiParser_legacyCliSucceeded, _LegacyApiParser_noLegacyApi, _LegacyApiParser_traverseActionTestSummaries, _LegacyApiParser_visitActionTestMetadata, _LegacyApiParser_visitActionTestSummary, _LegacyApiParser_visitActionTestSummaryGroup, _LegacyApiParser_processActivities, _LegacyApiParser_processFailures, _LegacyApiParser_parseFailureEntries, _LegacyApiParser_parseExpectedFailureEntries, _LegacyApiParser_toFailureMapEntry, _LegacyApiParser_parseAttachments, _LegacyApiParser_getRoot, _LegacyApiParser_getById, _LegacyApiParser_getFileById, _LegacyApiParser_xcresulttoolGetLegacy;
import { BufferResultFile, } from "@allurereport/reader-api";
import { randomUUID } from "node:crypto";
import { ensureObject, isDefined, isObject } from "../../../validation.js";
import { DEFAULT_BUNDLE_NAME, DEFAULT_EXPECTED_FAILURE_REASON, DEFAULT_STEP_NAME, DEFAULT_SUITE_ID, DEFAULT_SUITE_NAME, DEFAULT_TEST_NAME, applyApiCalls, createTestLabels, getDefaultAttachmentName, getMediaTypeByUti, getTargetDetails, getWorstStatusWithDetails, parseAsAllureApiActivity, prependTitle, secondsToMilliseconds, toSortedSteps, } from "../../utils.js";
import { xcresulttool, xcresulttoolBinary } from "../cli.js";
import { XcresultParser } from "../model.js";
import { mapWellKnownAttachmentName } from "../utils.js";
import { getBool, getDate, getDouble, getInt, getObjectArray, getRef, getString, getStringArray, getURL, getUnionType, } from "./parsing.js";
import { convertTraceLine, getTestClassFromSuites, resolveFailureStepStatus, resolveTestStatus, withNewSuite, } from "./utils.js";
import { XcActionTestSummaryIdentifiableObjectTypes } from "./xcModel.js";
const IDENTIFIER_URL_PREFIX = "test://com.apple.xcode/";
const ACTIVITY_TYPE_ATTACHMENT = "com.apple.dt.xctest.activity-type.attachmentContainer";
class LegacyApiParser extends XcresultParser {
    constructor(options) {
        super(options);
        _LegacyApiParser_instances.add(this);
        _LegacyApiParser_xcode16Plus.set(this, void 0);
        _LegacyApiParser_legacyCliSucceeded.set(this, false);
        _LegacyApiParser_noLegacyApi.set(this, false);
        this.legacyApiSucceeded = () => __classPrivateFieldGet(this, _LegacyApiParser_legacyCliSucceeded, "f") || !__classPrivateFieldGet(this, _LegacyApiParser_noLegacyApi, "f");
        _LegacyApiParser_processActivities.set(this, async (failures, activities) => {
            const steps = [];
            const files = [];
            const apiCalls = [];
            const failureSteps = [];
            for (const activity of activities) {
                const { activityType, title, start, finish, attachments: rawAttachments, subactivities: rawSubactivities, failureSummaryIDs, expectedFailureIDs, } = activity;
                const attachments = getObjectArray(rawAttachments);
                const subactivities = getObjectArray(rawSubactivities);
                const failureIds = getStringArray(failureSummaryIDs);
                const expectedFailureIds = getStringArray(expectedFailureIDs);
                const { steps: thisStepAttachmentSteps, files: thisStepFiles } = await __classPrivateFieldGet(this, _LegacyApiParser_parseAttachments, "f").call(this, attachments);
                if (getString(activityType) === ACTIVITY_TYPE_ATTACHMENT) {
                    files.push(...thisStepFiles);
                    steps.push(...thisStepAttachmentSteps);
                    continue;
                }
                const name = getString(title);
                if (attachments.length === 0 && subactivities.length === 0 && failureIds.length === 0) {
                    const parsedAllureApiCall = parseAsAllureApiActivity(name);
                    if (isDefined(parsedAllureApiCall)) {
                        apiCalls.push(parsedAllureApiCall);
                        continue;
                    }
                }
                const { steps: activitySubsteps, files: substepFiles, apiCalls: substepApiCalls, failureSteps: substepFailureSteps, } = await __classPrivateFieldGet(this, _LegacyApiParser_processActivities, "f").call(this, failures, subactivities);
                const { directFailureSteps, transitiveFailureSteps, message, trace, status } = resolveStepFailures(failureIds, expectedFailureIds, failures, substepFailureSteps);
                const substeps = toSortedSteps(thisStepAttachmentSteps, activitySubsteps, directFailureSteps);
                steps.push({
                    type: "step",
                    name: name ?? DEFAULT_STEP_NAME,
                    start: getDate(start),
                    stop: getDate(finish),
                    status: status ?? "passed",
                    message,
                    trace,
                    steps: substeps,
                });
                files.push(...thisStepFiles, ...substepFiles);
                apiCalls.push(...substepApiCalls);
                failureSteps.push(...transitiveFailureSteps);
            }
            fillDefaultAttachmentNames(steps);
            return { steps, files, apiCalls, failureSteps };
        });
        _LegacyApiParser_processFailures.set(this, async (failures, expectedFailures) => {
            const failureEntries = await __classPrivateFieldGet(this, _LegacyApiParser_parseFailureEntries, "f").call(this, failures);
            const expectedFailureEntries = await __classPrivateFieldGet(this, _LegacyApiParser_parseExpectedFailureEntries, "f").call(this, expectedFailures);
            return new Map([...failureEntries, ...expectedFailureEntries]);
        });
        _LegacyApiParser_parseFailureEntries.set(this, async (failures) => {
            const entries = [];
            for (const summary of getObjectArray(failures)) {
                const entry = await __classPrivateFieldGet(this, _LegacyApiParser_toFailureMapEntry, "f").call(this, summary);
                if (entry) {
                    entries.push(entry);
                }
            }
            return entries;
        });
        _LegacyApiParser_parseExpectedFailureEntries.set(this, async (expectedFailures) => {
            const entries = [];
            for (const { uuid, failureReason, failureSummary, isTopLevelFailure } of getObjectArray(expectedFailures)) {
                if (isObject(failureSummary)) {
                    const mapMessage = (message) => {
                        const prefix = getString(failureReason) ?? DEFAULT_EXPECTED_FAILURE_REASON;
                        return message ? prependTitle(`${prefix}:`, message, 2) : prefix;
                    };
                    const entry = await __classPrivateFieldGet(this, _LegacyApiParser_toFailureMapEntry, "f").call(this, failureSummary, {
                        uuid,
                        status: "passed",
                        isTopLevel: getBool(isTopLevelFailure),
                        mapMessage,
                    });
                    if (entry) {
                        entries.push(entry);
                    }
                }
            }
            return entries;
        });
        _LegacyApiParser_toFailureMapEntry.set(this, async ({ attachments, message: rawMessage, sourceCodeContext, timestamp, uuid: rawUuid, isTopLevelFailure, issueType, }, { uuid: explicitUuid, mapMessage, status: explicitStatus, isTopLevel: explicitTopLevelFlag } = {}) => {
            const { steps, files } = await __classPrivateFieldGet(this, _LegacyApiParser_parseAttachments, "f").call(this, getObjectArray(attachments));
            const message = getString(rawMessage);
            const status = explicitStatus ?? resolveFailureStepStatus(getString(issueType));
            const trace = convertStackTrace(sourceCodeContext);
            const start = getDate(timestamp);
            const uuid = getString(explicitUuid) ?? getString(rawUuid);
            return uuid
                ? [
                    uuid,
                    {
                        step: {
                            type: "step",
                            start,
                            stop: start,
                            duration: 0,
                            message: mapMessage?.(message) ?? message,
                            name: message,
                            status,
                            steps,
                            trace,
                        },
                        files,
                        isTopLevel: explicitTopLevelFlag ?? getBool(isTopLevelFailure),
                    },
                ]
                : undefined;
        });
        _LegacyApiParser_parseAttachments.set(this, async (attachments) => {
            const steps = [];
            const files = [];
            for (const attachment of attachments) {
                const { name: rawName, timestamp, uuid: rawUuid, filename: rawFileName, uniformTypeIdentifier, payloadRef, } = attachment;
                const uuid = getString(rawUuid);
                if (uuid) {
                    const start = getDate(timestamp);
                    const name = getString(rawName);
                    const fileName = ensureUniqueFileName(rawFileName);
                    const step = {
                        type: "attachment",
                        originalFileName: fileName,
                        name: mapWellKnownAttachmentName(name, start),
                        start,
                        stop: start,
                        contentType: getMediaTypeByUti(getString(uniformTypeIdentifier)),
                    };
                    const file = (await this.createAttachmentFile?.(uuid, fileName)) ?? (await __classPrivateFieldGet(this, _LegacyApiParser_getFileById, "f").call(this, payloadRef, fileName));
                    steps.push(step);
                    if (file) {
                        files.push(file);
                    }
                }
            }
            return { steps, files };
        });
        _LegacyApiParser_getRoot.set(this, () => __classPrivateFieldGet(this, _LegacyApiParser_xcresulttoolGetLegacy, "f").call(this, []));
        _LegacyApiParser_getById.set(this, async (ref) => {
            const id = getRef(ref);
            return id ? await __classPrivateFieldGet(this, _LegacyApiParser_xcresulttoolGetLegacy, "f").call(this, ["--id", id]) : undefined;
        });
        _LegacyApiParser_getFileById.set(this, async (ref, uniqueFileName) => {
            const id = getRef(ref);
            if (id) {
                const legacyFlagArgs = __classPrivateFieldGet(this, _LegacyApiParser_xcode16Plus, "f") ? ["--legacy"] : [];
                const content = await xcresulttoolBinary("get", ...legacyFlagArgs, "--path", this.xcResultPath, "--id", id);
                if (content) {
                    return new BufferResultFile(content, uniqueFileName);
                }
            }
        });
        _LegacyApiParser_xcresulttoolGetLegacy.set(this, async (args = []) => {
            if (__classPrivateFieldGet(this, _LegacyApiParser_noLegacyApi, "f")) {
                return undefined;
            }
            const legacyFlagArgs = __classPrivateFieldGet(this, _LegacyApiParser_xcode16Plus, "f") ? ["--legacy"] : [];
            const result = await xcresulttool("get", ...legacyFlagArgs, "--format", "json", "--path", this.xcResultPath, ...args);
            if (typeof result === "undefined") {
                if (!__classPrivateFieldGet(this, _LegacyApiParser_legacyCliSucceeded, "f")) {
                    __classPrivateFieldSet(this, _LegacyApiParser_noLegacyApi, true, "f");
                }
                return undefined;
            }
            __classPrivateFieldSet(this, _LegacyApiParser_legacyCliSucceeded, true, "f");
            return result;
        });
        __classPrivateFieldSet(this, _LegacyApiParser_xcode16Plus, options.xcode16Plus, "f");
    }
    async *parse() {
        const root = await __classPrivateFieldGet(this, _LegacyApiParser_getRoot, "f").call(this);
        const actions = getObjectArray(ensureObject(root)?.actions);
        const actionDescriminators = parseActionDiscriminators(actions);
        const multiTarget = isMultiTarget(actionDescriminators);
        const multiTestPlan = isMultiTestPlan(actionDescriminators);
        for (const { actionResult } of actions) {
            const { destination, testPlan } = actionDescriminators.shift();
            const testsRef = ensureObject(actionResult)?.testsRef;
            const testPlanRunSummaries = await __classPrivateFieldGet(this, _LegacyApiParser_getById, "f").call(this, testsRef);
            const summaries = ensureObject(testPlanRunSummaries)?.summaries;
            for (const { testableSummaries } of getObjectArray(summaries)) {
                for (const { name, tests } of getObjectArray(testableSummaries)) {
                    const bundle = getString(name) ?? DEFAULT_BUNDLE_NAME;
                    yield* __classPrivateFieldGet(this, _LegacyApiParser_instances, "m", _LegacyApiParser_traverseActionTestSummaries).call(this, tests, {
                        bundle,
                        suites: [],
                        destination,
                        testPlan,
                        multiTarget,
                        multiTestPlan,
                    });
                }
            }
        }
    }
}
_LegacyApiParser_xcode16Plus = new WeakMap(), _LegacyApiParser_legacyCliSucceeded = new WeakMap(), _LegacyApiParser_noLegacyApi = new WeakMap(), _LegacyApiParser_processActivities = new WeakMap(), _LegacyApiParser_processFailures = new WeakMap(), _LegacyApiParser_parseFailureEntries = new WeakMap(), _LegacyApiParser_parseExpectedFailureEntries = new WeakMap(), _LegacyApiParser_toFailureMapEntry = new WeakMap(), _LegacyApiParser_parseAttachments = new WeakMap(), _LegacyApiParser_getRoot = new WeakMap(), _LegacyApiParser_getById = new WeakMap(), _LegacyApiParser_getFileById = new WeakMap(), _LegacyApiParser_xcresulttoolGetLegacy = new WeakMap(), _LegacyApiParser_instances = new WeakSet(), _LegacyApiParser_traverseActionTestSummaries = async function* _LegacyApiParser_traverseActionTestSummaries(array, state) {
    for (const obj of getObjectArray(array)) {
        switch (getUnionType(obj, XcActionTestSummaryIdentifiableObjectTypes)) {
            case "ActionTestMetadata":
                yield* __classPrivateFieldGet(this, _LegacyApiParser_instances, "m", _LegacyApiParser_visitActionTestMetadata).call(this, obj, state);
                break;
            case "ActionTestSummary":
                yield* __classPrivateFieldGet(this, _LegacyApiParser_instances, "m", _LegacyApiParser_visitActionTestSummary).call(this, obj, state);
                break;
            case "ActionTestSummaryGroup":
                yield* __classPrivateFieldGet(this, _LegacyApiParser_instances, "m", _LegacyApiParser_visitActionTestSummaryGroup).call(this, obj, state);
                break;
        }
    }
}, _LegacyApiParser_visitActionTestMetadata = async function* _LegacyApiParser_visitActionTestMetadata({ summaryRef }, state) {
    const summary = await __classPrivateFieldGet(this, _LegacyApiParser_getById, "f").call(this, summaryRef);
    if (isObject(summary)) {
        yield* __classPrivateFieldGet(this, _LegacyApiParser_instances, "m", _LegacyApiParser_visitActionTestSummary).call(this, summary, state);
    }
}, _LegacyApiParser_visitActionTestSummary = async function* _LegacyApiParser_visitActionTestSummary({ arguments: args, duration, identifierURL, name: rawName, summary, activitySummaries, tags, trackedIssues, failureSummaries, expectedFailures, testStatus, repetitionPolicySummary, skipNoticeSummary, }, state) {
    const { bundle, suites, destination: { hostName } = {} } = state;
    const fullName = getString(identifierURL) ?? randomUUID();
    const projectName = parseProjectName(fullName);
    const functionName = getString(rawName);
    const name = getString(summary) ?? functionName ?? DEFAULT_TEST_NAME;
    const status = getString(testStatus);
    const labels = createTestLabels({
        hostName,
        projectName,
        bundle,
        functionName,
        suites: suites.map(({ name: suite }) => suite),
        className: getTestClassFromSuites(suites),
        tags: parseTestTags(tags),
    });
    const parameters = getAllTestResultParameters(state, args, repetitionPolicySummary);
    const failures = await __classPrivateFieldGet(this, _LegacyApiParser_processFailures, "f").call(this, failureSummaries, expectedFailures);
    const { steps: activitySteps, files, apiCalls, } = await __classPrivateFieldGet(this, _LegacyApiParser_processActivities, "f").call(this, failures, getObjectArray(activitySummaries));
    const { message, trace, steps: failureSteps, status: worstFailedStepStatus, } = resolveTestFailures(failures, skipNoticeSummary);
    const steps = toSortedSteps(activitySteps, failureSteps);
    const testResult = {
        uuid: randomUUID(),
        fullName,
        name,
        duration: secondsToMilliseconds(getDouble(duration)),
        labels,
        parameters,
        steps,
        links: parseTrackedIssues(trackedIssues),
        message,
        status: resolveTestStatus(status, worstFailedStepStatus),
        trace,
    };
    applyApiCalls(testResult, apiCalls);
    yield* files;
    yield* iterateFailureFiles(failures);
    yield testResult;
}, _LegacyApiParser_visitActionTestSummaryGroup = async function* _LegacyApiParser_visitActionTestSummaryGroup({ name, identifierURL, summary, subtests }, state) {
    const suiteId = getString(name);
    const suiteName = getString(summary) ?? suiteId ?? DEFAULT_SUITE_NAME;
    const suiteUri = getString(identifierURL);
    const { suites: parentSuites } = state;
    const suites = withNewSuite(parentSuites, suiteId ?? DEFAULT_SUITE_ID, suiteUri, suiteName);
    yield* __classPrivateFieldGet(this, _LegacyApiParser_instances, "m", _LegacyApiParser_traverseActionTestSummaries).call(this, subtests, { ...state, suites });
};
export default LegacyApiParser;
const parseActionDiscriminators = (actions) => {
    return actions.map(({ runDestination, testPlanName }) => ({
        destination: parseDestination(runDestination),
        testPlan: getString(testPlanName),
    }));
};
const isMultiTarget = (discriminators) => new Set(discriminators
    .map(({ destination }) => destination)
    .filter(isDefined)
    .map(({ name }) => name)
    .filter(isDefined)).size > 1;
const isMultiTestPlan = (discriminators) => new Set(discriminators.map(({ testPlan }) => testPlan).filter(isDefined)).size > 1;
const parseDestination = (element) => {
    if (isObject(element)) {
        const { displayName, targetArchitecture, targetDeviceRecord, localComputerRecord } = element;
        const targetName = getString(displayName);
        const hostName = parseHostName(localComputerRecord);
        const architecture = getString(targetArchitecture);
        const { model, platform, osVersion } = parseTargetDevice(targetDeviceRecord) ?? {};
        return {
            name: targetName,
            hostName,
            targetDetails: getTargetDetails({ architecture, model, platform, osVersion }),
        };
    }
};
const parseHostName = (element) => getString(ensureObject(element)?.name);
const parseTargetDevice = (element) => {
    if (isObject(element)) {
        const { modelName, operatingSystemVersion, platformRecord } = element;
        return {
            model: getString(modelName),
            platform: parsePlatform(platformRecord),
            osVersion: getString(operatingSystemVersion),
        };
    }
};
const parsePlatform = (element) => getString(ensureObject(element)?.userDescription);
const iterateFailureFiles = function* (failures) {
    for (const { files } of failures.values()) {
        yield* files;
    }
};
const parseTrackedIssues = (issues) => getObjectArray(issues)
    .map(({ comment, identifier, url: rawUrl }) => {
    const issueId = getString(identifier);
    const name = getString(comment) ?? (issueId ? `Issue ${issueId}` : undefined);
    const url = getURL(rawUrl) ?? issueId;
    return url ? { type: "issue", name, url } : undefined;
})
    .filter(isDefined);
const convertStackTrace = (sourceCodeContext) => {
    const callStack = ensureObject(sourceCodeContext)?.callStack;
    return getObjectArray(callStack)
        .map(({ symbolInfo }) => symbolInfo)
        .filter(isObject)
        .map(({ location, symbolName }) => {
        const { filePath, lineNumber } = ensureObject(location) ?? {};
        return convertTraceLine(getString(symbolName), getString(filePath), getInt(lineNumber));
    })
        .filter(isDefined)
        .join("\n");
};
const fillDefaultAttachmentNames = (steps) => {
    const attachmentSteps = steps.filter((s) => s.type === "attachment");
    const totalAttachments = attachmentSteps.length;
    attachmentSteps.forEach((s, i) => {
        s.name ?? (s.name = getDefaultAttachmentName(i, totalAttachments));
    });
};
const resolveStepFailures = (failureUids, expectedFailureUids, failures, failureStepsOfSubsteps) => {
    const stepFailures = [...failureUids, ...expectedFailureUids].map((uuid) => failures.get(uuid));
    const directFailureSteps = resolveStepFailureSubsteps(stepFailures);
    const transitiveFailureSteps = toSortedSteps(directFailureSteps, failureStepsOfSubsteps);
    const { status, trace, message } = getWorstStatusWithDetails(transitiveFailureSteps) ?? {};
    return { status, message, trace, directFailureSteps, transitiveFailureSteps };
};
const resolveTestFailures = (failures, skipNoticeSummary) => {
    const allFailures = Array.from(failures.values());
    const transitiveFailureSteps = allFailures.map(({ step }) => step);
    const { status, trace, message } = getWorstStatusWithDetails(transitiveFailureSteps) ?? {};
    const steps = resolveTestFailureSteps(allFailures);
    if (!message && !trace && isObject(skipNoticeSummary)) {
        const { fileName, lineNumber, message: skipMessage } = skipNoticeSummary;
        return {
            steps,
            status,
            message: getString(skipMessage),
            trace: convertTraceLine(undefined, getString(fileName), getInt(lineNumber)),
        };
    }
    return { status, message, trace, steps };
};
const resolveTestFailureSteps = (failures) => failures.filter(({ isTopLevel }) => isTopLevel).map(({ step }) => step);
const resolveStepFailureSubsteps = (stepFailures) => {
    return stepFailures.map((failure) => failure?.step ??
        {
            type: "step",
            duration: 0,
            message: "An unknown failure has occured",
            status: "broken",
        });
};
const ensureUniqueFileName = (fileName) => getString(fileName) ?? randomUUID();
const getAllTestResultParameters = (state, args, repetition) => [...convertActionParameters(state), convertRepetitionParameter(repetition), ...convertTestParameters(args)].filter(isDefined);
const convertActionParameters = ({ destination, testPlan, multiTarget, multiTestPlan }) => {
    const parameters = [];
    if (multiTestPlan && testPlan) {
        parameters.push({ name: "Test Plan", value: testPlan, excluded: true });
    }
    if (destination) {
        const { name, targetDetails } = destination;
        if (isDefined(name)) {
            parameters.push({ name: "Device", value: name });
            if (multiTarget && targetDetails) {
                parameters.push({ name: "Device Details", value: targetDetails, excluded: true });
            }
        }
    }
    return parameters;
};
const convertTestParameters = (args) => getObjectArray(args).map(({ parameter, value }) => {
    const parameterName = getParameterName(parameter);
    const argumentValue = getArgumentValue(value);
    return isDefined(parameterName) && isDefined(argumentValue)
        ? {
            name: parameterName,
            value: argumentValue,
        }
        : undefined;
});
const convertRepetitionParameter = (repetition) => {
    const { iteration, totalIterations } = ensureObject(repetition) ?? {};
    const current = getInt(iteration);
    const total = getInt(totalIterations);
    if (current) {
        return {
            name: "Repetition",
            value: total ? `Repetition ${current} of ${total}` : `Repetition ${current}`,
            excluded: true,
        };
    }
};
const parseProjectName = (url) => {
    if (url && url.startsWith(IDENTIFIER_URL_PREFIX)) {
        const urlPath = url.slice(IDENTIFIER_URL_PREFIX.length);
        const projectNameEnd = urlPath.indexOf("/");
        if (projectNameEnd !== -1) {
            const projectName = urlPath.slice(0, projectNameEnd);
            try {
                return decodeURIComponent(projectName);
            }
            catch {
                return projectName;
            }
        }
    }
};
const parseTestTags = (tags) => getObjectArray(tags)
    .map(({ name }) => getString(name))
    .filter(isDefined);
const getParameterName = (parameter) => isObject(parameter) ? (getString(parameter.name) ?? getString(parameter.label)) : undefined;
const getArgumentValue = (parameter) => isObject(parameter) ? getString(parameter.description) : undefined;
