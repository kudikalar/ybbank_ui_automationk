import * as preact from 'preact';
import { JSX, FunctionalComponent, VNode, ComponentChildren, FunctionComponent } from 'preact';
import { Signal } from '@preact/signals';
import { AttachmentTestStepResult, Statistic, TestStatus, TestStatusTransition, ChartMode, PieChartValues } from '@allurereport/core-api';
import { RecursiveTree, Status } from 'global';
import * as preact_compat from 'preact/compat';
import { HTMLAttributes, CSSProperties } from 'preact/compat';
import { Options } from 'sortablejs';
import { LangLocale } from '@allurereport/web-commons';
import { Serie as Serie$1 } from '@/components/Charts/TrendChart';
import { AxisProps } from '@nivo/axes';
import { Serie as Serie$2, Datum as Datum$1, LineSvgProps, Point } from '@nivo/line';
import { ScaleSymlogSpec, ScaleSpec } from '@nivo/scales';
import { Margin } from '@nivo/core';
import { LegendProps } from '@nivo/legends';

declare const allureIcons: {
    arrowsChevronDown: string;
    environment: string;
    amazon: string;
    azure: string;
    bitbucket: string;
    circleci: string;
    drone: string;
    gitlab: string;
    github: string;
    jenkins: string;
    draggable: string;
    lineAlertsAlertCircle: string;
    lineAlertsNotificationBox: string;
    lineAlertsNew: string;
    lineAlertsMalfunctioned: string;
    lineAlertsFixed: string;
    lineAlertsRegressed: string;
    lineArrowsChevronDown: string;
    lineArrowsChevronDownDouble: string;
    lineArrowsChevronRight: string;
    lineArrowsChevronUp: string;
    lineArrowsChevronUpDouble: string;
    lineArrowsCornerDownRight: string;
    lineArrowsExpand3: string;
    lineArrowsRefreshCcw1: string;
    lineArrowsSortLineAsc: string;
    lineArrowsSortLineDesc: string;
    lineArrowsSwitchVertical1: string;
    lineChartsBarChartSquare: string;
    lineDevBug2: string;
    lineDevCodeSquare: string;
    lineDevDataflow3: string;
    lineFilesClipboardCheck: string;
    lineFilesFile2: string;
    lineFilesFileAttachment2: string;
    lineFilesFolder: string;
    lineGeneralCheck: string;
    lineGeneralChecklist3: string;
    lineGeneralCopy3: string;
    lineGeneralDownloadCloud: string;
    lineGeneralEqual: string;
    lineGeneralEye: string;
    lineGeneralHomeLine: string;
    lineGeneralLink1: string;
    lineGeneralLinkExternal: string;
    lineGeneralSearchMd: string;
    lineGeneralSettings1: string;
    lineGeneralXClose: string;
    lineGeneralZap: string;
    lineHelpersFlag: string;
    lineHelpersPlayCircle: string;
    lineIconBomb2: string;
    lineImagesImage: string;
    lineLayoutsColumn2: string;
    lineLayoutsLayoutTop: string;
    lineLayoutsMaximize2: string;
    lineLayoutsMinimize2: string;
    lineSecurityKey: string;
    lineShapesDotCircle: string;
    lineShapesMoon: string;
    lineShapesSun: string;
    lineTimeClockStopwatch: string;
    playwrightLogo: string;
    reportLogo: string;
    solidAlertCircle: string;
    solidCheckCircle: string;
    solidHelpCircle: string;
    solidMinusCircle: string;
    solidXCircle: string;
    solidPlusCircle: string;
    spinner: string;
    view: string;
    viewOff: string;
    lineGeneralCheckCircle: string;
    lineGeneralHelpCircle: string;
    lineGeneralInfoCircle: string;
    lineGeneralMinusCircle: string;
    lineGeneralXCircle: string;
    testNew: string;
};
type SvgIconProps = Omit<JSX.HTMLAttributes<SVGElement>, "className" | "id" | "size" | "inline"> & {
    "size"?: "xs" | "s" | "m";
    "className"?: string;
    "id": string;
    "inline"?: boolean;
    "data-testid"?: string;
};
declare const SvgIcon: ({ id, size, inline, className, "data-testid": dataTestId, }: SvgIconProps) => JSX.Element;

type BaseBtnProps = {
    text?: string;
    isPending?: boolean;
    size?: "s" | "m" | "l";
    style?: "primary" | "outline" | "ghost" | "flat" | "raised";
    action?: "default" | "danger" | "positive";
    icon?: string;
    iconSize?: "xs" | "s" | "m";
    fullWidth?: boolean;
    isIconButton?: boolean;
    isDropdownButton?: boolean;
    onClick?: (e: MouseEvent) => void;
    type?: HTMLButtonElement["type"];
    isDisabled?: boolean;
    isActive?: boolean;
    focusable?: boolean;
    href?: string;
    target?: HTMLAnchorElement["target"];
    className?: string;
    dataTestId?: string;
};
type ButtonProps = Omit<BaseBtnProps, "text" | "isIconButton" | "isDropdownButton"> & Pick<Required<BaseBtnProps>, "text">;
declare const Button: (props: ButtonProps) => preact.JSX.Element;
type IconButtonProps = Omit<BaseBtnProps, "text" | "icon" | "autoFocus" | "fullWidth" | "isIconButton" | "isDropdownButton"> & Pick<Required<BaseBtnProps>, "icon">;
declare const IconButton: (props: IconButtonProps) => preact.JSX.Element;
type DropdownButtonProps = Omit<BaseBtnProps, "type" | "autoFocus" | "isDropdownButton" | "isIconButton" | "text" | "isActive"> & Pick<Required<BaseBtnProps>, "text"> & {
    isExpanded?: boolean;
};
declare const DropdownButton: (props: DropdownButtonProps) => preact.JSX.Element;

type SpinnerProps = {
    size?: "s" | "m";
};
declare const Spinner: ({ size }: SpinnerProps) => preact.JSX.Element;

type TextProps = ({
    type?: "paragraph";
    size?: "s" | "m" | "l";
} | {
    type: "ui";
    size: "s" | "m" | "l" | "xs";
}) & {
    className?: string;
    bold?: boolean;
    tag?: keyof JSX.IntrinsicElements;
} & Omit<JSX.HTMLAttributes, "type" | "size" | "className" | "bold" | "tag">;
declare const Text: FunctionalComponent<TextProps>;
type CodeProps = {
    type?: "paragraph" | "ui";
    size?: "s" | "m";
    className?: string;
    bold?: boolean;
    tag?: keyof JSX.IntrinsicElements;
};
declare const Code: FunctionalComponent<CodeProps>;
type HeadingProps = {
    size?: "s" | "m" | "l";
    className?: string;
    tag?: keyof JSX.IntrinsicElements;
} & Omit<JSX.HTMLAttributes, "size" | "className" | "tag">;
declare const Heading: FunctionalComponent<HeadingProps>;

interface TooltipWrapperProps {
    "tooltipText"?: string;
    "tooltipTextAfterClick"?: string;
    "tooltipComponent"?: FunctionalComponent | VNode;
    "children": VNode;
    "placement"?: "top" | "bottom" | "left" | "right";
    "triggerMode"?: "hover" | "click";
    "autoHideDelay"?: number;
    "isTriggerActive"?: boolean;
    "data-testid"?: string;
}
declare const TooltipWrapper: FunctionalComponent<TooltipWrapperProps>;

interface StoreSignalState<T> {
    error?: string;
    loading: boolean;
    data?: T;
}
type LoadableProps<T, K = T> = {
    source: Signal<StoreSignalState<T>>;
    transformData?: (data: T) => K;
    renderData: (data: K) => JSX.Element;
    renderLoader?: () => JSX.Element;
    renderError?: (error: string) => JSX.Element;
};
declare const Loadable: <T, K = T>(props: LoadableProps<T, K>) => JSX.Element | null;

declare const PageLoader: () => preact.JSX.Element;

type Props$3 = {
    placeholder?: string;
    invalid?: string;
    error?: string;
    value: string;
    onChange: (value: string) => void;
    changeDebounce?: number;
};
declare const SearchBox: (props: Props$3) => preact.JSX.Element;

declare const Menu: {
    (props: {
        children: ComponentChildren;
        isInitialOpened?: boolean;
        size?: "s" | "m" | "l" | "xl";
        placement?: "bottom-start" | "bottom-end";
        menuTrigger: (props: {
            onClick: () => void;
            isOpened: boolean;
            setIsOpened: (isOpened: boolean) => void;
        }) => VNode;
        menuTriggerWrapper?: "div" | "span";
    }): preact.JSX.Element;
    Section(props: {
        children: ComponentChildren;
    }): preact.JSX.Element;
    Item(props: ItemProps): preact.JSX.Element;
    ItemWithCheckmark(props: ItemProps & {
        isChecked: boolean;
    }): preact.JSX.Element;
};
type ItemProps = {
    children: ComponentChildren;
    onClick?: () => void;
    leadingIcon?: string;
    rightSlot?: ComponentChildren;
    closeMenuOnClick?: boolean;
    ariaLabel?: string;
    setIsOpened?: (isOpened: boolean) => void;
};

interface ArrowButtonProps {
    isOpened?: boolean;
    iconSize?: "m" | "xs" | "s";
    buttonSize?: "m" | "xs" | "s";
    className?: string;
    icon?: string;
    onClick?: VoidFunction;
    tag?: keyof JSX.IntrinsicElements;
}
declare const ArrowButton: FunctionalComponent<ArrowButtonProps>;

type ModalGalleryProps = {
    attachments: AttachmentTestStepResult[] | undefined;
};
interface ModalDataProps<T = any> {
    data?: T;
    component: VNode;
    preview?: boolean;
    isModalOpen?: boolean;
    closeModal?: () => void;
    attachments?: AttachmentTestStepResult[];
    title?: string;
}
interface ModalTranslations {
    tooltipPreview: string;
    tooltipDownload: string;
    openInNewTabButton: string;
}
interface ModalTranslationsProps {
    translations: ModalTranslations;
}
declare const Modal: ({ data, isModalOpen, preview, component, attachments, closeModal, translations, title, }: ModalDataProps & ModalTranslationsProps) => preact.JSX.Element | null;

interface TreeProps {
    statistic?: Statistic;
    reportStatistic?: Statistic;
    tree: RecursiveTree;
    name?: string;
    root?: boolean;
    statusFilter?: Status;
    collapsedTrees: Set<string>;
    toggleTree: (id: string) => void;
    navigateTo: (id: string) => void;
    routeId?: string;
}
declare const Tree: FunctionalComponent<TreeProps>;

interface TreeHeaderProps {
    statistic?: Statistic;
    reportStatistic?: Statistic;
    categoryTitle: string;
    isOpened: boolean;
    toggleTree: () => void;
    statusFilter?: Status;
}
declare const TreeHeader: FunctionComponent<TreeHeaderProps>;

interface TreeSectionProps {
    title: string;
    isOpened: boolean;
    toggleTree: () => void;
    icon?: string;
}
declare const TreeSection: FunctionComponent<TreeSectionProps>;

interface TreeItemProps {
    name: string;
    status: TestStatus;
    duration?: number;
    retriesCount?: number;
    flaky?: boolean;
    transition?: TestStatusTransition;
    transitionTooltip?: string;
    id: string;
    groupOrder: number;
    marked?: boolean;
    navigateTo: (id: string) => void;
}
declare const TreeItem: FunctionComponent<TreeItemProps>;

interface TestStatusIconProps {
    status?: TestStatus;
    className?: string;
    classNameIcon?: string;
}
declare const TreeItemIcon: FunctionalComponent<TestStatusIconProps>;

interface TreeStatusBarProps {
    statistic?: Statistic;
    reportStatistic?: Statistic;
    maxWidth?: number;
    minWidth?: number;
    offset?: number;
    statusFilter?: Status;
}
declare const TreeStatusBar: FunctionalComponent<TreeStatusBarProps>;

interface AttachmentTestStepResultProps {
    item: AttachmentTestStepResult;
    previewable?: boolean;
}
declare const Attachment: FunctionalComponent<AttachmentTestStepResultProps>;

declare const AttachmentCode: FunctionalComponent<{
    item: AttachmentTestStepResult;
    attachment: {
        text?: string;
    };
}>;

type HtmlAttachmentPreviewProps = {
    attachment: {
        text: string;
    };
};
declare const HtmlPreview: FunctionalComponent<HtmlAttachmentPreviewProps>;

declare const AttachmentImage: FunctionalComponent<{
    attachment: {
        img: string;
        originalFileName: string;
    };
}>;

declare const AttachmentVideo: FunctionalComponent<{
    attachment: {
        src: string;
        contentType?: string;
    };
}>;

declare const AttachmentEmpty: ({ children }: {
    children: ComponentChildren;
}) => preact.JSX.Element;

declare const CodeViewer: FunctionalComponent<{
    code?: string;
    children?: ComponentChildren;
    className?: string;
}>;

type Props$2 = {
    size?: "s" | "m" | "l";
    count: number;
    truncateCount?: boolean;
    status?: TestStatus;
};
declare const Counter: (props: Props$2) => preact.JSX.Element;

type Props$1 = {
    value: boolean;
    label: string;
    onChange: (value: boolean) => void;
    focusable?: boolean;
};
declare const Toggle: (props: Props$1) => preact.JSX.Element;

type Props = {
    href?: string;
    children: ComponentChildren;
    onClick?: (e: MouseEvent) => void;
};
declare const Link: (props: Props) => preact.JSX.Element;

declare const Label: FunctionComponent;

type StatusLabelProps = {
    status: TestStatus;
    className?: string;
};
declare const StatusLabel: FunctionalComponent<StatusLabelProps>;

declare const ReportLogoFull: (props: {
    className?: string;
}) => preact.JSX.Element;

declare const ReportLogo: (props: {
    className?: string;
    logo?: string;
}) => preact.JSX.Element;

interface WidgetProps {
    title: string;
}
declare const Widget: FunctionalComponent<WidgetProps>;

type TagSkin = "successful" | "failed" | "warning" | "neutral" | "successful-light" | "failed-light" | "warning-light" | "neutral-light";
interface TagProps {
    "className"?: string;
    "skin"?: TagSkin;
    "data-testid"?: string;
}
declare const Tag: FunctionComponent<TagProps>;

type GridKind = "default" | "swap";
interface GridProps extends HTMLAttributes<HTMLDivElement> {
    options?: Options;
    kind?: GridKind;
    className?: string;
}
declare const Grid: FunctionComponent<GridProps>;

interface GridItemProps extends HTMLAttributes<HTMLDivElement> {
    className?: string;
    dndEnabled?: boolean;
}
declare const GridItem: FunctionComponent<GridItemProps>;

interface LanguagePickerProps {
    locale: LangLocale;
    setLocale: (locale: LangLocale) => void;
    availableLocales?: LangLocale[];
}
declare const LanguagePicker: ({ locale, setLocale, availableLocales }: LanguagePickerProps) => preact.JSX.Element;

type Theme = "light" | "dark";
interface ThemeButtonProps {
    theme: Theme;
    getTheme: () => void;
    toggleTheme: () => void;
}
declare const ThemeButton: ({ theme, toggleTheme, getTheme }: ThemeButtonProps) => preact.JSX.Element;

interface TrendChartWidgetPropsTranslations {
    "no-results": string;
}
interface TrendChartWidgetProps<TSlice = {
    metadata: {
        executionId: string;
    };
}> {
    title: string;
    mode: ChartMode;
    items: readonly Serie$1[];
    slices: readonly TSlice[];
    min: number;
    max: number;
    height?: CSSProperties["height"];
    width?: CSSProperties["width"];
    rootAriaLabel?: string;
    translations: TrendChartWidgetPropsTranslations;
}
declare const TrendChartWidget: ({ title, mode, items, slices, min, max, height, width, rootAriaLabel, translations, }: TrendChartWidgetProps) => preact_compat.JSX.Element;

interface ComingSoonChartWidgetProps {
    title: string;
}
declare const ComingSoonChartWidget: FunctionalComponent<ComingSoonChartWidgetProps>;

type SuccessRatePieChartProps = PieChartValues & {
    className?: string;
};
declare const SuccessRatePieChart: ({ slices, percentage, className }: SuccessRatePieChartProps) => preact.JSX.Element;

type Datum = Omit<Datum$1, "x" | "y"> & {
    x: string | number | Date;
    y: number;
};
type Serie = Omit<Serie$2, "id" | "data"> & {
    id: string | number;
    data: readonly Datum[];
};
type BaseLineSvgProps = Omit<LineSvgProps, "useMesh" | "enableSlices">;
declare enum TrendChartKind {
    Mesh = "Mesh",
    SlicesX = "SlicesX",
    SlicesY = "SlicesY"
}
type TrendChartKindConfig = Pick<LineSvgProps, "useMesh" | "enableSlices">;
type SymlogScaleOptions = Pick<ScaleSymlogSpec, "constant" | "reverse">;
interface Slice {
    id: string;
    height: number;
    width: number;
    x: number;
    y: number;
    x0: number;
    y0: number;
    points: Point[];
}
type TrendChartSliceClickHandler = (slice: Slice, event: MouseEvent) => void;
type TrendChartSliceTouchHandler = (slice: Slice, event: TouchEvent) => void;
interface BaseTrendChartProps extends Omit<BaseLineSvgProps, "onClick" | "onTouchEnd" | "axisBottom"> {
    rootAriaLabel?: string;
    emptyLabel?: string;
    emptyAriaLabel?: string;
    width?: CSSProperties["width"];
    height?: CSSProperties["height"];
    axisBottom?: Omit<AxisProps, "tickValues">;
}
interface MeshTrendChartProps extends BaseTrendChartProps {
    kind: TrendChartKind.Mesh;
    onClick?: (point: Point, event: MouseEvent) => void;
    onTouchEnd?: (point: Point, event: TouchEvent) => void;
}
interface SlicesTrendChartProps extends BaseTrendChartProps {
    kind: TrendChartKind.SlicesX | TrendChartKind.SlicesY;
    onSliceClick?: TrendChartSliceClickHandler;
    onSliceTouchEnd?: TrendChartSliceTouchHandler;
}
type TrendChartProps = MeshTrendChartProps | SlicesTrendChartProps;

declare const TrendChart: FunctionalComponent<TrendChartProps>;

declare const defaultTrendChartLegendConfig: LegendProps;
declare const defaultTrendChartAxisBottomConfig: AxisProps;
declare const defaultTrendChartAxisLeftConfig: AxisProps;
declare const defaultTrendChartMarginConfig: Margin;
declare const defaultTrendChartXScaleConfig: ScaleSpec;
declare const defaultTrendChartYScaleConfig: ScaleSpec;
declare const defaultTrendChartConfig: Partial<LineSvgProps>;

declare const makeSymlogScale: (min: number, max: number, options?: SymlogScaleOptions) => ScaleSymlogSpec;
declare const makeSymlogScaleBySeries: (series: Serie[], options?: SymlogScaleOptions) => ScaleSymlogSpec;

export { ArrowButton, Attachment, AttachmentCode, AttachmentEmpty, AttachmentImage, AttachmentVideo, Button, Code, CodeViewer, ComingSoonChartWidget, Counter, DropdownButton, Grid, GridItem, Heading, HtmlPreview, IconButton, Label, LanguagePicker, Link, Loadable, Menu, Modal, PageLoader, ReportLogo, ReportLogoFull, SearchBox, Spinner, StatusLabel, SuccessRatePieChart, SvgIcon, Tag, Text, ThemeButton, Toggle, TooltipWrapper, Tree, TreeHeader, TreeItem, TreeItemIcon, TreeSection, TreeStatusBar, TrendChart, TrendChartKind, TrendChartWidget, Widget, allureIcons, defaultTrendChartAxisBottomConfig, defaultTrendChartAxisLeftConfig, defaultTrendChartConfig, defaultTrendChartLegendConfig, defaultTrendChartMarginConfig, defaultTrendChartXScaleConfig, defaultTrendChartYScaleConfig, makeSymlogScale, makeSymlogScaleBySeries };
export type { ComingSoonChartWidgetProps, Datum, GridItemProps, GridProps, LanguagePickerProps, MeshTrendChartProps, ModalDataProps, ModalGalleryProps, ModalTranslations, ModalTranslationsProps, Serie, Slice, SlicesTrendChartProps, SymlogScaleOptions, TagProps, TagSkin, Theme, ThemeButtonProps, TrendChartKindConfig, TrendChartProps, TrendChartSliceClickHandler, TrendChartSliceTouchHandler };
