import { AllureReport, QualityGateState, readConfig, stringifyQualityGateResults } from "@allurereport/core";
import { findMatching } from "@allurereport/directory-watcher";
import { Command, Option } from "clipanion";
import * as console from "node:console";
import { realpath } from "node:fs/promises";
import { join } from "node:path";
import { exit, cwd as processCwd } from "node:process";
import pm from "picomatch";
import * as typanion from "typanion";
import { red } from "yoctocolors";
export class QualityGateCommand extends Command {
    constructor() {
        super(...arguments);
        this.resultsDir = Option.String({
            required: false,
            name: "Pattern to match test results directories in the current working directory (default: ./**/allure-results)",
        });
        this.config = Option.String("--config,-c", {
            description: "The path Allure config file",
        });
        this.fastFail = Option.Boolean("--fast-fail", {
            description: "Force the command to fail if there are any rule failures",
        });
        this.maxFailures = Option.String("--max-failures", {
            description: "The maximum number of rule failures to allow before failing the command",
            validator: typanion.isNumber(),
        });
        this.minTestsCount = Option.String("--min-tests-count", {
            description: "The minimum number of tests to run before validating the quality gate",
            validator: typanion.isNumber(),
        });
        this.successRate = Option.String("--success-rate", {
            description: "The minimum success rate to allow before failing the command",
            validator: typanion.isNumber(),
        });
        this.knownIssues = Option.String("--known-issues", {
            description: "Path to the known issues file. Updates the file and quarantines failed tests when specified",
        });
        this.cwd = Option.String("--cwd", {
            description: "The working directory for the command to run (default: current working directory)",
        });
    }
    async execute() {
        const cwd = await realpath(this.cwd ?? processCwd());
        const resultsDir = (this.resultsDir ?? "./**/allure-results").replace(/[\\/]$/, "");
        const { maxFailures, minTestsCount, successRate, fastFail, knownIssues: knownIssuesPath } = this;
        const config = await readConfig(cwd, this.config, {
            knownIssuesPath,
        });
        const rules = {};
        const resultsDirectories = new Set();
        const matcher = pm(resultsDir, {
            dot: true,
            contains: true,
        });
        if (maxFailures !== undefined) {
            rules.maxFailures = maxFailures;
        }
        if (minTestsCount !== undefined) {
            rules.minTestsCount = minTestsCount;
        }
        if (successRate !== undefined) {
            rules.successRate = successRate;
        }
        if (fastFail) {
            rules.fastFail = fastFail;
        }
        config.plugins = [];
        if (Object.keys(rules).length > 0) {
            config.qualityGate = {
                rules: [rules],
            };
        }
        const allureReport = new AllureReport(config);
        if (!allureReport.hasQualityGate) {
            console.error(red("Quality gate is not configured!"));
            console.error(red("Add qualityGate to the config or consult help to know, how to use the command with command-line arguments"));
            exit(-1);
            return;
        }
        await findMatching(cwd, resultsDirectories, (dirent) => {
            if (dirent.isDirectory()) {
                const fullPath = join(dirent?.parentPath ?? dirent?.path, dirent.name);
                return matcher(fullPath);
            }
            return false;
        });
        if (resultsDirectories.size === 0) {
            console.error("No Allure results directories found");
            exit(0);
            return;
        }
        const knownIssues = await allureReport.store.allKnownIssues();
        const state = new QualityGateState();
        allureReport.realtimeSubscriber.onTestResults(async (trsIds) => {
            const trs = await Promise.all(trsIds.map((id) => allureReport.store.testResultById(id)));
            const notHiddenTrs = trs.filter((tr) => !tr.hidden);
            const { results, fastFailed } = await allureReport.validate({
                trs: notHiddenTrs,
                knownIssues,
                state,
            });
            if (!fastFailed) {
                return;
            }
            console.error(stringifyQualityGateResults(results));
            exit(1);
        });
        await allureReport.start();
        for (const dir of resultsDirectories) {
            await allureReport.readDirectory(dir);
        }
        await allureReport.done();
        const allTrs = await allureReport.store.allTestResults({ includeHidden: false });
        const validationResults = await allureReport.validate({
            trs: allTrs,
            knownIssues,
        });
        if (validationResults.results.length === 0) {
            exit(0);
            return;
        }
        console.error(stringifyQualityGateResults(validationResults.results));
        exit(1);
    }
}
QualityGateCommand.paths = [["quality-gate"]];
QualityGateCommand.usage = Command.Usage({
    description: "Returns status code 1 if there any test failure above specified success rate",
    details: "This command validates the test results against quality gates defined in the configuration.",
    examples: [
        ["quality-gate ./allure-results", "Validate the test results in the ./allure-results directory"],
        [
            "quality-gate ./allure-results --config custom-config.js",
            "Validate the test results using a custom configuration file",
        ],
    ],
});
