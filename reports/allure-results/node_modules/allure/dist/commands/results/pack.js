var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _ResultsPackCommand_instances, _ResultsPackCommand_formatSize;
import { findMatching } from "@allurereport/directory-watcher";
import AdmZip from "adm-zip";
import { Command, Option } from "clipanion";
import * as console from "node:console";
import * as fs from "node:fs/promises";
import { realpath } from "node:fs/promises";
import { basename, join, resolve } from "node:path";
import pm from "picomatch";
import { green, red } from "yoctocolors";
export class ResultsPackCommand extends Command {
    constructor() {
        super(...arguments);
        _ResultsPackCommand_instances.add(this);
        this.resultsDir = Option.String({
            required: false,
            name: "Pattern to match test results directories in the current working directory (default: ./**/allure-results)",
        });
        this.name = Option.String("--name", {
            description: "The archive name (default: allure-results.zip)",
        });
        this.cwd = Option.String("--cwd", {
            description: "The working directory for the command to run (default: current working directory)",
        });
    }
    async execute() {
        const cwd = await realpath(this.cwd ?? process.cwd());
        const resultsDir = (this.resultsDir ?? "./**/allure-results").replace(/[\\/]$/, "");
        const archiveName = this.name ?? "allure-results.zip";
        const resultsDirectories = new Set();
        const resultsFiles = new Set();
        const matcher = pm(resultsDir, {
            dot: true,
            contains: true,
        });
        await findMatching(cwd, resultsDirectories, (dirent) => {
            if (dirent.isDirectory()) {
                const fullPath = join(dirent?.parentPath ?? dirent?.path, dirent.name);
                return matcher(fullPath);
            }
            return false;
        });
        if (resultsDirectories.size === 0) {
            console.log(red(`No test results directories found matching pattern: ${resultsDir}`));
            return;
        }
        for (const dir of resultsDirectories) {
            const files = await fs.readdir(dir);
            if (files.length === 0) {
                continue;
            }
            for (const file of files) {
                resultsFiles.add(resolve(dir, file));
            }
        }
        const outputPath = join(cwd, archiveName);
        const zip = new AdmZip();
        for (const file of resultsFiles) {
            try {
                const stats = await fs.stat(file);
                if (stats.isFile()) {
                    zip.addLocalFile(file, "", basename(file));
                }
            }
            catch (error) {
                console.log(red(`Error adding file ${file} to archive: ${error.message}`));
            }
        }
        try {
            zip.writeZip(outputPath);
            const stats = await fs.stat(outputPath);
            console.log(green(`Archive created successfully: ${outputPath}`));
            console.log(green(`Total size: ${__classPrivateFieldGet(this, _ResultsPackCommand_instances, "m", _ResultsPackCommand_formatSize).call(this, stats.size)}. ${resultsFiles.size} results files have been collected`));
        }
        catch (err) {
            console.log(red(`Error creating archive: ${err.message}`));
            throw err;
        }
    }
}
_ResultsPackCommand_instances = new WeakSet(), _ResultsPackCommand_formatSize = function _ResultsPackCommand_formatSize(bytes) {
    const units = ["bytes", "KB", "MB", "GB"];
    let size = bytes;
    let unitIndex = 0;
    while (size >= 1024 && unitIndex < units.length - 1) {
        size /= 1024;
        unitIndex++;
    }
    if (bytes === 0) {
        return "0 bytes";
    }
    return unitIndex === 0 ? `${Math.round(size)} ${units[unitIndex]}` : `${size.toFixed(2)} ${units[unitIndex]}`;
};
ResultsPackCommand.paths = [["results", "pack"]];
ResultsPackCommand.usage = Command.Usage({
    description: "Creates .zip archive with test results",
    category: "Allure Test Results",
    details: "This command creates .zip archive with all test results which can be collected in the project",
    examples: [
        ["results pack", "Creates .zip archive with test results in directories matched to ./**/allure-results pattern"],
        [
            "results pack ./**/foo/**/my-results --name results.zip",
            "Creates results.zip archive with test results in directories matched to ./**/foo/**/my-results pattern",
        ],
    ],
});
